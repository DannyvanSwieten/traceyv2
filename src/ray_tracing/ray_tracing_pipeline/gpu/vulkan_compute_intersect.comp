void traceRaysEXT(uint tlas, uint sbtRecordOffset, uint sbtRecordStride, uint missIndex, uint rayFlags, uint cullFlags, vec3 rayOrigin, float rayTmin, vec3 rayDirection, float rayTmax, uint payloadIndex);

const uint INVALID_INDEX = 0xFFFFFFFFu;

// [USER_SHADER_CODE]

bool intersectAABB(Ray r, vec3 bmin, vec3 bmax, float tMin, float tMax, inout float tEnter, inout float tExit)
{
    vec3 t0 = (bmin - r.origin) * r.invDirection;
    vec3 t1 = (bmax - r.origin) * r.invDirection;

    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);

    tEnter = max(tMin, max(tmin3.x, max(tmin3.y, tmin3.z)));
    tExit  = min(tMax, min(tmax3.x, min(tmax3.y, tmax3.z)));

    return tExit >= tEnter;
}

bool intersectTriangle(Ray r, vec3 v0, vec3 e1, vec3 e2, float tMin, float tMax, inout float t, inout vec2 uv)
{
    vec3 p  = cross(r.direction, e2);
    float det = dot(e1, p);

    // two-sided:
    if (abs(det) < 1e-8) return false;
    float invDet = 1.0 / det;

    vec3 s = r.origin - v0;
    float u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(s, e1);
    float v = dot(r.direction, q) * invDet;
    if (v < 0.0 || (u + v) > 1.0) return false;

    float tt = dot(e2, q) * invDet;
    if (tt < tMin || tt > tMax) return false;

    t = tt;
    uv = vec2(u, v);
    return true;
}

void loadTriangleInfo(uint triangleIndex, inout vec3 v0, inout vec3 e0, inout vec3 e1, inout vec3 normal)
{
    TriangleInfo tri = blasTriangles.triangles[triangleIndex];

    v0 = vec3(tri.v0x, tri.v0y, tri.v0z);
    e0 = vec3(tri.e0x, tri.e0y, tri.e0z);
    e1 = vec3(tri.e1x, tri.e1y, tri.e1z);
    normal = vec3(tri.nx, tri.ny, tri.nz);
}

// BvhNode encoding (CPU-identical):
// - firstChildOrPrim: inner = left child offset relative to bvhBase (right is implicit left+1),
//                    leaf  = first index into BLAS primIndices stream
// - primCountAndType: inner = 0, leaf = count in low 24 bits (type in high 8 bits)

HitInfo traverseBVH(uint bvhBase, uint triangleOffset, Ray ray, float tMin, float tMax)
{   
    HitInfo best;
    best.t = tMax;
    best.triangleIndex = INVALID_INDEX;
    best.instanceIndex = INVALID_INDEX;
    best.barycentricU = 0.0;
    best.barycentricV = 0.0;

    const int MAX_STACK = 64;
    // small fixed stack
    uint stack[MAX_STACK];
    int sp = 0;
    int iterGuard = 0;

    // push root
    stack[sp++] = bvhBase; // root index (absolute)

    while (sp > 0)
    {
        uint nodeIndex = stack[--sp];
        BvhNode node = blasNodes.nodes[nodeIndex];

        uint primCount = (node.primCountAndType & 0x00FFFFFFu);
        bool isLeaf = (primCount > 0u);
        if (isLeaf)
        {
            vec3 aabbMin = vec3(node.minx, node.miny, node.minz);
            vec3 aabbMax = vec3(node.maxx, node.maxy, node.maxz);

            float tE, tX;
            if (!intersectAABB(ray, aabbMin, aabbMax, tMin, best.t, tE, tX))
                continue;
            // Leaf: indices are a contiguous range in the BLAS primIndices stream.
            // NOTE: This shader assumes the primIndices stream is also concatenated per-BLAS using the same base offset as triangles.
            uint firstPrimIndex = triangleOffset + node.firstChildOrPrim;

            for (uint i = 0u; i < primCount; ++i)
            {
                uint originalPrimId = blasPrimitiveIndices.primitiveIndices[firstPrimIndex + i];

                // Triangles are stored in original triangle-id order per BLAS, concatenated by triangleOffset.
                uint triIndex = triangleOffset + originalPrimId;

                vec3 v0, e0, e1, normal;
                loadTriangleInfo(triIndex, v0, e0, e1, normal);

                float t;
                vec2 uv;
                if (intersectTriangle(ray, v0, e0, e1, tMin, best.t, t, uv))
                {
                    best.t = t;
                    best.triangleIndex = originalPrimId;
                    best.barycentricU = uv.x;
                    best.barycentricV = uv.y;
                }
            }
        }
        else
        {
            // Interior (CPU-identical): right child is implicit left+1
            uint left  = bvhBase + node.firstChildOrPrim;
            uint right = left + 1u;

            float tEL, tXL, tER, tXR;
            vec3 aabbMinL = vec3(blasNodes.nodes[left].minx, blasNodes.nodes[left].miny, blasNodes.nodes[left].minz);
            vec3 aabbMaxL = vec3(blasNodes.nodes[left].maxx, blasNodes.nodes[left].maxy, blasNodes.nodes[left].maxz);
            vec3 aabbMinR = vec3(blasNodes.nodes[right].minx, blasNodes.nodes[right].miny, blasNodes.nodes[right].minz);
            vec3 aabbMaxR = vec3(blasNodes.nodes[right].maxx, blasNodes.nodes[right].maxy, blasNodes.nodes[right].maxz);
            bool hitL = intersectAABB(ray, aabbMinL,  aabbMaxL,  tMin, best.t, tEL, tXL);
            bool hitR = intersectAABB(ray, aabbMinR, aabbMaxR, tMin, best.t, tER, tXR);

            if (hitL && hitR)
            {
                // push farther first so nearer is processed next
                if (tEL < tER)
                {
                    stack[sp++] = right;
                    stack[sp++] = left;
                }
                else
                {
                    stack[sp++] = left;
                    stack[sp++] = right;
                }
            }
            else if (hitL)
            {
                stack[sp++] = left;
            }
            else if (hitR)
            {
                stack[sp++] = right;
            }
        }
    }

    return best;
}

bool intersectTlas(Ray ray, inout HitInfo hitInfo)
{
    // Assumes ray.direction is normalized in raygen (so tWorld can be computed via dot(delta, dir)).
    for (uint i = 0u; i < tlasInstances.instanceCount; ++i)
    {
        Instance instance = tlasInstances.instances[i];
        InverseTransforms instanceInverseTransform = tlasInstanceTransforms.inv[i];

        vec3 localO = (instanceInverseTransform.worldToObj * vec4(ray.origin, 1.0)).xyz;
        vec3 localD = (instanceInverseTransform.worldToObj * vec4(ray.direction, 0.0)).xyz;

        // Avoid inf/nan invDirection if localD has zeros
        Ray localRay;
        localRay.origin = localO;
        localRay.direction = localD;
        localRay.invDirection = 1.0 / localD;

        // Fetch BLAS info (blasAddress is used as an index in the compute path).
        BlasInfo blasInfo = blasInfos.blases[instance.blasAddress];
        uint bvhBase = blasInfo.rootNodeIndex;
        uint triangleOffset = blasInfo.triangleOffset;

        // Traverse in object space, but keep the best.t bound in world space (convert on accept).
        HitInfo hit = traverseBVH(bvhBase, triangleOffset, localRay, 0.001, hitInfo.t);

        if (hit.triangleIndex != INVALID_INDEX)
        {
            // Convert local hit to world-space t along the original ray.
            vec3 hitPosLocal = localRay.origin + localRay.direction * hit.t;
            vec3 hitPosWorld = (instanceInverseTransform.objToWorld * vec4(hitPosLocal, 1.0)).xyz;

            float tWorld = dot(hitPosWorld - ray.origin, ray.direction);

            // Reject behind/too-far hits.
            if (tWorld <= 0.0 || tWorld >= hitInfo.t)
                continue;

            // Accept best hit.
            hit.t = tWorld;
            hit.instanceIndex = i;
            hitInfo = hit;

            // Populate built-ins for shading (matches ray tracing built-ins convention).
            builtIn.hitT = tWorld;
            builtIn.primitiveID = hitInfo.triangleIndex;
            builtIn.instanceID = i;
            builtIn.instanceCustomIndex = instance.customIndexAndMask;
            builtIn.objectToWorld = mat4x3(instanceInverseTransform.objToWorld);
            builtIn.worldToObject = mat4x3(instanceInverseTransform.worldToObj);

            TriangleInfo triangleInfo = blasTriangles.triangles[triangleOffset + hitInfo.triangleIndex];
            builtIn.hitNormal = vec3(triangleInfo.nx, triangleInfo.ny, triangleInfo.nz);
            // Transform normal to world space (inverse-transpose): invTrans(objToWorld) == transpose(worldToObj)
            builtIn.hitNormal = normalize((transpose(instanceInverseTransform.worldToObj) * vec4(builtIn.hitNormal, 0.0)).xyz);
        }
    }

    return (hitInfo.triangleIndex != INVALID_INDEX);
}

void traceRaysEXT(uint tlas, uint sbtRecordOffset, uint sbtRecordStride, uint missIndex, uint rayFlags, uint foo, vec3 rayOrigin, float rayTmin, vec3 rayDirection, float rayTmax, uint payloadIndex)
{
    Ray ray;
    ray.origin = rayOrigin;
    ray.direction = rayDirection;
    ray.invDirection = 1.0 / rayDirection;

    HitInfo hitInfo;
    hitInfo.t = rayTmax;
    hitInfo.triangleIndex = INVALID_INDEX;
    hitInfo.instanceIndex = INVALID_INDEX;
    hitInfo.barycentricU = 0.0;
    hitInfo.barycentricV = 0.0;

    bool hit = intersectTlas(ray, hitInfo);

    // Ensure these are valid for user hit shaders even if intersectTlas didn't set them (miss path).
    if (!hit) {
        builtIn.hitT = rayTmax;
        builtIn.primitiveID = INVALID_INDEX;
        builtIn.instanceID = INVALID_INDEX;
    }

    uint hitIndex = 0u;

    if (hit)
    {
        // [HIT_SHADER_CALLS]
    }
    else
    {
        // [MISS_SHADER_CALLS]
    }

}

void main()
{
    // Populate built-in variables
    builtIn.hitT = 1000000;
    builtIn.launchID = gl_GlobalInvocationID.xyz;
    builtIn.launchSize = gl_NumWorkGroups.xyz * gl_WorkGroupSize.xyz;

    rayGenMain();
}