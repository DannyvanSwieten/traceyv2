#version 460

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

struct PathHeader{
    float originX;
    float originY;
    float originZ;
    float tMin;

    float directionX;
    float directionY;
    float directionZ;
    float tMax;
};

struct Ray{
    vec3 origin;
    vec3 direction;
    vec3 invDirection;
};

struct Instance{
    // Column-major 3x4 transform rows
    vec4 row0;
    vec4 row1;
    vec4 row2;
    uint customIndexAndMask;
    uint sbtOffsetAndFlags;
    uint blasAddress;
    uint padding;
};

struct BlasInfo{
    uint rootNodeIndex;
    uint triangleCount;
    uint triangleOffset;
    uint padding;
};

struct BvhNode{
    float minx, miny, minz;
    uint firstChildOrPrim; // For inner nodes: left child index. For leaf nodes: first triangle index.
    float maxx, maxy, maxz;
    uint primCountAndType; // For inner nodes: right child index. For leaf nodes: number of triangles.
};

struct HitInfo{
    float t;
    uint triangleIndex;
    uint instanceIndex;
    float barycentricU;
    float barycentricV;
};

struct TriangleInfo{
    float v0x, v0y, v0z;
    float e0x, e0y, e0z;
    float e1x, e1y, e1z;
};

struct InverseTransforms{
    mat4 objToWorld;
    mat4 worldToObj;
};

layout(std430, set = 0, binding = 0) buffer PathHeaders {
    PathHeader headers[];
};

layout(std430, set = 0, binding = 1) buffer RayQueue{
    uint count;        // number of valid entries in rayIndices
    uint rayIndices[]; // compact list of path/ray indices
};

PathHeader getPathHeader(uint rayIndex) {
    return headers[rayIndex];
}

layout(std430, set = 0, binding = 2) buffer HitInfos {
    HitInfo hits[];
};

layout(std430, set = 0, binding = 3) readonly buffer TLASInstances {
    uint instanceCount;
    uint padding[3];
    Instance instances[];
} tlasInstances;

layout(std430, set = 0, binding = 4) readonly buffer BvhNodes {
    BvhNode nodes[];
} blasNodes;

layout(std430, set = 0, binding = 5) readonly buffer BlasInfos {
    BlasInfo blases[];
} blasInfos;

layout(std430, set = 0, binding = 6) readonly buffer Triangles {
    TriangleInfo triangles[];
} blasTriangles;

layout(std430, set = 0, binding = 7) readonly buffer PrimitiveIndices {
    uint primitiveIndices[];
} blasPrimitiveIndices;

layout(std430, set = 0, binding = 8) readonly buffer TLASInstanceTransforms {
    InverseTransforms inv[];
} tlasInstanceTransforms;

void traceRaysEXT(uint tlas, uint sbtRecordOffset, uint sbtRecordStride, uint missIndex, uint rayFlags, uint cullFlags, vec3 rayOrigin, float rayTmin, vec3 rayDirection, float rayTmax, uint payloadIndex);

const uint INVALID_INDEX = 0xFFFFFFFFu;

bool intersectAABB(Ray r, vec3 bmin, vec3 bmax, float tMin, float tMax, inout float tEnter, inout float tExit)
{
    vec3 t0 = (bmin - r.origin) * r.invDirection;
    vec3 t1 = (bmax - r.origin) * r.invDirection;

    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);

    tEnter = max(tMin, max(tmin3.x, max(tmin3.y, tmin3.z)));
    tExit  = min(tMax, min(tmax3.x, min(tmax3.y, tmax3.z)));

    return tExit >= tEnter;
}

bool intersectTriangle(Ray r, vec3 v0, vec3 e1, vec3 e2, float tMin, float tMax, inout float t, inout vec2 uv)
{
    vec3 p  = cross(r.direction, e2);
    float det = dot(e1, p);

    // two-sided:
    if (abs(det) < 1e-8) return false;
    float invDet = 1.0 / det;

    vec3 s = r.origin - v0;
    float u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(s, e1);
    float v = dot(r.direction, q) * invDet;
    if (v < 0.0 || (u + v) > 1.0) return false;

    float tt = dot(e2, q) * invDet;
    if (tt < tMin || tt > tMax) return false;

    t = tt;
    uv = vec2(u, v);
    return true;
}

void loadTriangleInfo(uint triangleIndex, inout vec3 v0, inout vec3 e0, inout vec3 e1, inout vec3 normal)
{
    TriangleInfo tri = blasTriangles.triangles[triangleIndex];

    v0 = vec3(tri.v0x, tri.v0y, tri.v0z);
    e0 = vec3(tri.e0x, tri.e0y, tri.e0z);
    e1 = vec3(tri.e1x, tri.e1y, tri.e1z);
}

// --- Instance transform helpers (VkAccelerationStructureInstanceKHR-style, 3x4 row-major) ---

// Row-major point transform: p' = A*p + t
vec3 transformPointRowMajor(vec4 r0, vec4 r1, vec4 r2, vec3 p)
{
    return vec3(
        r0.x * p.x + r0.y * p.y + r0.z * p.z + r0.w,
        r1.x * p.x + r1.y * p.y + r1.z * p.z + r1.w,
        r2.x * p.x + r2.y * p.y + r2.z * p.z + r2.w
    );
}

// Row-major vector transform: v' = A*v
vec3 transformVectorRowMajor(vec4 r0, vec4 r1, vec4 r2, vec3 v)
{
    return vec3(
        r0.x * v.x + r0.y * v.y + r0.z * v.z,
        r1.x * v.x + r1.y * v.y + r1.z * v.z,
        r2.x * v.x + r2.y * v.y + r2.z * v.z
    );
}

// Invert a 3x4 row-major affine transform (works for uniform/non-uniform scale as long as A is invertible).
void invertRowMajor3x4(vec4 r0, vec4 r1, vec4 r2, out vec4 ir0, out vec4 ir1, out vec4 ir2)
{
    // Build A using COLUMNS (GLSL matrices are column-major)
    mat3 A = mat3(
        vec3(r0.x, r1.x, r2.x),
        vec3(r0.y, r1.y, r2.y),
        vec3(r0.z, r1.z, r2.z)
    );

    vec3 t = vec3(r0.w, r1.w, r2.w);

    mat3 Ainv = inverse(A);
    vec3 tinv = -(Ainv * t);

    // We want to output ROWS of Ainv in ir0/ir1/ir2
    mat3 AinvT = transpose(Ainv);

    ir0 = vec4(AinvT[0][0], AinvT[0][1], AinvT[0][2], tinv.x);
    ir1 = vec4(AinvT[1][0], AinvT[1][1], AinvT[1][2], tinv.y);
    ir2 = vec4(AinvT[2][0], AinvT[2][1], AinvT[2][2], tinv.z);
}

// Convert row-major 3x4 rows into a column-major mat4x3 (as used by gl_ObjectToWorldEXT/gl_WorldToObjectEXT).
mat4x3 rowMajor3x4ToMat4x3(vec4 r0, vec4 r1, vec4 r2)
{
    vec3 c0 = vec3(r0.x, r1.x, r2.x);
    vec3 c1 = vec3(r0.y, r1.y, r2.y);
    vec3 c2 = vec3(r0.z, r1.z, r2.z);
    vec3 c3 = vec3(r0.w, r1.w, r2.w);
    return mat4x3(c0, c1, c2, c3);
}

// BvhNode encoding (CPU-identical):
// - firstChildOrPrim: inner = left child offset relative to bvhBase (right is implicit left+1),
//                    leaf  = first index into BLAS primIndices stream
// - primCountAndType: inner = 0, leaf = count in low 24 bits (type in high 8 bits)

HitInfo traverseBVH(uint bvhBase, uint triangleOffset, Ray ray, float tMin, float tMax)
{   
    HitInfo best;
    best.t = tMax;
    best.triangleIndex = INVALID_INDEX;
    best.instanceIndex = INVALID_INDEX;
    best.barycentricU = 0.0;
    best.barycentricV = 0.0;

    const int MAX_STACK = 32;
    // small fixed stack
    uint stack[MAX_STACK];
    int sp = 0;
    int iterGuard = 0;

    // push root
    stack[sp++] = bvhBase; // root index (absolute)

    while (sp > 0)
    {
        uint nodeIndex = stack[--sp];
        BvhNode node = blasNodes.nodes[nodeIndex];
        vec3 aabbMin = vec3(node.minx, node.miny, node.minz);
        vec3 aabbMax = vec3(node.maxx, node.maxy, node.maxz);

        float tE, tX;
        if (!intersectAABB(ray, aabbMin, aabbMax, tMin, best.t, tE, tX))
            continue;

        uint primCount = (node.primCountAndType & 0x00FFFFFFu);
        bool isLeaf = (primCount > 0u);
        if (isLeaf)
        {
            // Leaf: indices are a contiguous range in the BLAS primIndices stream.
            // NOTE: This shader assumes the primIndices stream is also concatenated per-BLAS using the same base offset as triangles.
            uint firstPrimIndex = triangleOffset + node.firstChildOrPrim;

            for (uint i = 0u; i < primCount; ++i)
            {
                uint originalPrimId = blasPrimitiveIndices.primitiveIndices[firstPrimIndex + i];

                // Triangles are stored in original triangle-id order per BLAS, concatenated by triangleOffset.
                uint triIndex = triangleOffset + originalPrimId;

                vec3 v0, e0, e1, normal;
                loadTriangleInfo(triIndex, v0, e0, e1, normal);

                float t;
                vec2 uv;
                if (intersectTriangle(ray, v0, e0, e1, tMin, best.t, t, uv))
                {
                    best.t = t;
                    best.triangleIndex = originalPrimId;
                    best.barycentricU = uv.x;
                    best.barycentricV = uv.y;
                }
            }
        }
        else
        {
            // Interior (CPU-identical): right child is implicit left+1
            uint left  = bvhBase + node.firstChildOrPrim;
            uint right = left + 1u;

            float tEL, tXL, tER, tXR;
            vec3 aabbMinL = vec3(blasNodes.nodes[left].minx, blasNodes.nodes[left].miny, blasNodes.nodes[left].minz);
            vec3 aabbMaxL = vec3(blasNodes.nodes[left].maxx, blasNodes.nodes[left].maxy, blasNodes.nodes[left].maxz);
            vec3 aabbMinR = vec3(blasNodes.nodes[right].minx, blasNodes.nodes[right].miny, blasNodes.nodes[right].minz);
            vec3 aabbMaxR = vec3(blasNodes.nodes[right].maxx, blasNodes.nodes[right].maxy, blasNodes.nodes[right].maxz);
            bool hitL = intersectAABB(ray, aabbMinL,  aabbMaxL,  tMin, best.t, tEL, tXL);
            bool hitR = intersectAABB(ray, aabbMinR, aabbMaxR, tMin, best.t, tER, tXR);

            if (hitL && hitR)
            {
                // push farther first so nearer is processed next
                if (tEL < tER)
                {
                    stack[sp++] = right;
                    stack[sp++] = left;
                }
                else
                {
                    stack[sp++] = left;
                    stack[sp++] = right;
                }
            }
            else if (hitL)
            {
                stack[sp++] = left;
            }
            else if (hitR)
            {
                stack[sp++] = right;
            }
        }
    }

    return best;
}

bool intersectTlas(Ray ray, inout HitInfo hitInfo)
{
    // Assumes ray.direction is normalized in raygen (so tWorld can be computed via dot(delta, dir)).
    for (uint i = 0u; i < tlasInstances.instanceCount; ++i)
    {
        Instance instance = tlasInstances.instances[i];
        InverseTransforms instanceInverseTransform = tlasInstanceTransforms.inv[i];

        vec4 inverseRow0, inverseRow1, inverseRow2;
        invertRowMajor3x4(
            instance.row0,
            instance.row1,
            instance.row2,
            inverseRow0,
            inverseRow1,
            inverseRow2
        );

        vec3 localO = transformPointRowMajor(
            inverseRow0,
            inverseRow1,
            inverseRow2,
            ray.origin
        );
        vec3 localD = transformVectorRowMajor(
            inverseRow0,
            inverseRow1,
            inverseRow2,
            ray.direction
        );
        // Avoid inf/nan invDirection if localD has zeros
        Ray localRay;
        localRay.origin = localO;
        localRay.direction = localD;
        localRay.invDirection = 1.0 / localD;

        // Fetch BLAS info (blasAddress is used as an index in the compute path).
        BlasInfo blasInfo = blasInfos.blases[instance.blasAddress];
        uint bvhBase = blasInfo.rootNodeIndex;
        uint triangleOffset = blasInfo.triangleOffset;

        // Traverse in object space, but keep the best.t bound in world space (convert on accept).
        HitInfo hit = traverseBVH(bvhBase, triangleOffset, localRay, 0.001, hitInfo.t);

        if (hit.triangleIndex != INVALID_INDEX)
        {
            // Convert local hit to world-space t along the original ray.
            vec3 hitPosLocal = localRay.origin + localRay.direction * hit.t;
            vec3 hitPosWorld = transformPointRowMajor(
                instance.row0,
                instance.row1,
                instance.row2,
                hitPosLocal
            );

            float tWorld = dot(hitPosWorld - ray.origin, ray.direction);

            // Reject behind/too-far hits.
            if (tWorld <= 0.0 || tWorld >= hitInfo.t)
                continue;

            // Accept best hit.
            hit.t = tWorld;
            hit.instanceIndex = i;
            hitInfo = hit;
        }
    }

    return (hitInfo.triangleIndex != INVALID_INDEX);
}

void main()
{
    uint tid = gl_GlobalInvocationID.x;
    if (tid >= count) {
        return;
    }
    uint rayIndex = rayIndices[tid];
    PathHeader header = getPathHeader(rayIndex);
    Ray ray;
    ray.origin = vec3(header.originX, header.originY, header.originZ);
    ray.direction = vec3(header.directionX, header.directionY, header.directionZ);
    ray.invDirection = 1.0 / ray.direction; // NOTE: ensure direction components are non-zero or handle safely

    HitInfo hitInfo;
    hitInfo.t = header.tMax;
    hitInfo.triangleIndex = INVALID_INDEX;
    hitInfo.instanceIndex = INVALID_INDEX;
    hitInfo.barycentricU = 0.0;
    hitInfo.barycentricV = 0.0;

    bool hit = intersectTlas(ray, hitInfo);
    hits[rayIndex] = hitInfo;
}