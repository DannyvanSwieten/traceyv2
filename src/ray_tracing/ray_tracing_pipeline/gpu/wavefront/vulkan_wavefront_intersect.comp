#version 450

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
} pc;

struct PathHeader{
    float originX;
    float originY;
    float originZ;
    float tMin;

    float directionX;
    float directionY;
    float directionZ;
    float tMax;
};

struct Ray{
    vec3 origin;
    vec3 direction;
    vec3 invDirection;
};

struct Instance{
    // Column-major 3x4 transform rows
    vec4 row0;
    vec4 row1;
    vec4 row2;
    uint customIndexAndMask;
    uint sbtOffsetAndFlags;
    uint blasAddress;
    uint padding;
};

struct BlasInfo{
    uint rootNodeIndex;
    uint triangleCount;
    uint triangleOffset;
    uint padding;
};

struct BvhNode{
    float minx, miny, minz;
    uint firstChildOrPrim; // For inner nodes: left child index. For leaf nodes: first triangle index.
    float maxx, maxy, maxz;
    uint primCountAndType; // For inner nodes: right child index. For leaf nodes: number of triangles.
};

struct HitInfo{
    float t;

    uint triangleIndex;
    uint instanceIndex;

    float barycentricU;
    float barycentricV;
    
    float normalX;
    float normalY;
    float normalZ;
};

struct TriangleInfo{
    float v0x, v0y, v0z;
    float e0x, e0y, e0z;
    float e1x, e1y, e1z;
    float nx, ny, nz;
};

struct InverseTransforms{
    mat4 objToWorld;
    mat4 worldToObj;
};

// Wavefront internal buffers at bindings 50-52
layout(std430, set = 0, binding = 50) readonly buffer PathHeaders {
    PathHeader headers[];
} pathHeaders;

layout(std430, set = 0, binding = 51) readonly buffer RayQueue{
    uint count;        // number of valid entries in rayIndices
    uint padding[3];
    uint rayIndices[]; // compact list of path/ray indices
} rayQueue;

PathHeader getPathHeader(uint rayIndex) {
    return pathHeaders.headers[rayIndex];
}

layout(std430, set = 0, binding = 52) buffer HitInfos {
    HitInfo hits[];
} hitInfos;

// Debug output image removed - debug visualization should be done in hit/miss shaders
// layout(set = 0, binding = 7, rgba8) uniform writeonly image2D debugOutputImage;

// TLAS buffers at bindings 0-5
layout(std430, set = 0, binding = 0) readonly buffer TLASInstances {
    uint instanceCount;
    uint padding[3];
    Instance instances[];
} tlasInstances;

layout(std430, set = 0, binding = 1) readonly buffer BvhNodes {
    BvhNode nodes[];
} blasNodes;

layout(std430, set = 0, binding = 2) readonly buffer BlasInfos {
    BlasInfo blases[];
} blasInfos;

layout(std430, set = 0, binding = 3) readonly buffer Triangles {
    TriangleInfo triangles[];
} blasTriangles;

layout(std430, set = 0, binding = 4) readonly buffer PrimitiveIndices {
    uint primitiveIndices[];
} blasPrimitiveIndices;

layout(std430, set = 0, binding = 5) readonly buffer TLASInstanceTransforms {
    InverseTransforms inv[];
} tlasInstanceTransforms;

void traceRaysEXT(uint tlas, uint sbtRecordOffset, uint sbtRecordStride, uint missIndex, uint rayFlags, uint cullFlags, vec3 rayOrigin, float rayTmin, vec3 rayDirection, float rayTmax, uint payloadIndex);

const uint INVALID_INDEX = 0xFFFFFFFFu;

bool intersectAABB(Ray r, vec3 bmin, vec3 bmax, float tMin, float tMax, inout float tEnter, inout float tExit)
{
    vec3 t0 = (bmin - r.origin) * r.invDirection;
    vec3 t1 = (bmax - r.origin) * r.invDirection;

    vec3 tmin3 = min(t0, t1);
    vec3 tmax3 = max(t0, t1);

    tEnter = max(tMin, max(tmin3.x, max(tmin3.y, tmin3.z)));
    tExit  = min(tMax, min(tmax3.x, min(tmax3.y, tmax3.z)));

    return tExit >= tEnter;
}

bool intersectTriangle(Ray r, vec3 v0, vec3 e1, vec3 e2, float tMin, float tMax, inout float t, inout vec2 uv)
{
    vec3 p  = cross(r.direction, e2);
    float det = dot(e1, p);

    // two-sided:
    if (abs(det) < 1e-8) return false;
    float invDet = 1.0 / det;

    vec3 s = r.origin - v0;
    float u = dot(s, p) * invDet;
    if (u < 0.0 || u > 1.0) return false;

    vec3 q = cross(s, e1);
    float v = dot(r.direction, q) * invDet;
    if (v < 0.0 || (u + v) > 1.0) return false;

    float tt = dot(e2, q) * invDet;
    if (tt < tMin || tt > tMax) return false;

    t = tt;
    uv = vec2(u, v);
    return true;
}

void loadTriangleInfo(uint triangleIndex, inout vec3 v0, inout vec3 e0, inout vec3 e1, inout vec3 normal)
{
    TriangleInfo tri = blasTriangles.triangles[triangleIndex];

    v0 = vec3(tri.v0x, tri.v0y, tri.v0z);
    e0 = vec3(tri.e0x, tri.e0y, tri.e0z);
    e1 = vec3(tri.e1x, tri.e1y, tri.e1z);
    normal = vec3(tri.nx, tri.ny, tri.nz);
}

// BvhNode encoding (CPU-identical):
// - firstChildOrPrim: inner = left child offset relative to bvhBase (right is implicit left+1),
//                    leaf  = first index into BLAS primIndices stream
// - primCountAndType: inner = 0, leaf = count in low 24 bits (type in high 8 bits)

HitInfo traverseBVH(uint bvhBase, uint triangleOffset, Ray ray, float tMin, float tMax)
{   
    HitInfo best;
    best.t = tMax;
    best.triangleIndex = INVALID_INDEX;
    best.instanceIndex = INVALID_INDEX;
    best.barycentricU = 0.0;
    best.barycentricV = 0.0;

    const int MAX_STACK = 64;
    // small fixed stack
    uint stack[MAX_STACK];
    int sp = 0;
    int iterGuard = 0;

    // push root
    stack[sp++] = bvhBase; // root index (absolute)

    while (sp > 0)
    {
        uint nodeIndex = stack[--sp];
        BvhNode node = blasNodes.nodes[nodeIndex];

        uint primCount = (node.primCountAndType & 0x00FFFFFFu);
        bool isLeaf = (primCount > 0u);
        if (isLeaf)
        {
            // Leaf: test leaf AABB before intersecting primitives.
            vec3 aabbMin = vec3(node.minx, node.miny, node.minz);
            vec3 aabbMax = vec3(node.maxx, node.maxy, node.maxz);

            float tE, tX;
            if (!intersectAABB(ray, aabbMin, aabbMax, tMin, best.t, tE, tX))
                continue;
            // Leaf: indices are a contiguous range in the BLAS primIndices stream.
            // NOTE: This shader assumes the primIndices stream is also concatenated per-BLAS using the same base offset as triangles.
            uint firstPrimIndex = triangleOffset + node.firstChildOrPrim;

            for (uint i = 0u; i < primCount; ++i)
            {
                uint originalPrimId = blasPrimitiveIndices.primitiveIndices[firstPrimIndex + i];

                // Triangles are stored in original triangle-id order per BLAS, concatenated by triangleOffset.
                uint triIndex = triangleOffset + originalPrimId;

                vec3 v0, e0, e1, normal;
                loadTriangleInfo(triIndex, v0, e0, e1, normal);

                float t;
                vec2 uv;
                if (intersectTriangle(ray, v0, e0, e1, tMin, best.t, t, uv))
                {
                    best.t = t;
                    best.triangleIndex = originalPrimId;
                    best.barycentricU = uv.x;
                    best.barycentricV = uv.y;
                    best.normalX = normal.x;
                    best.normalY = normal.y;
                    best.normalZ = normal.z;
                }
            }
        }
        else
        {
            // Interior (CPU-identical): right child is implicit left+1
            uint left  = bvhBase + node.firstChildOrPrim;
            uint right = left + 1u;

            float tEL, tXL, tER, tXR;
            vec3 aabbMinL = vec3(blasNodes.nodes[left].minx, blasNodes.nodes[left].miny, blasNodes.nodes[left].minz);
            vec3 aabbMaxL = vec3(blasNodes.nodes[left].maxx, blasNodes.nodes[left].maxy, blasNodes.nodes[left].maxz);
            vec3 aabbMinR = vec3(blasNodes.nodes[right].minx, blasNodes.nodes[right].miny, blasNodes.nodes[right].minz);
            vec3 aabbMaxR = vec3(blasNodes.nodes[right].maxx, blasNodes.nodes[right].maxy, blasNodes.nodes[right].maxz);
            bool hitL = intersectAABB(ray, aabbMinL,  aabbMaxL,  tMin, best.t, tEL, tXL);
            bool hitR = intersectAABB(ray, aabbMinR, aabbMaxR, tMin, best.t, tER, tXR);

            if (hitL && hitR)
            {
                // push farther first so nearer is processed next
                if (tEL < tER)
                {
                    stack[sp++] = right;
                    stack[sp++] = left;
                }
                else
                {
                    stack[sp++] = left;
                    stack[sp++] = right;
                }
            }
            else if (hitL)
            {
                stack[sp++] = left;
            }
            else if (hitR)
            {
                stack[sp++] = right;
            }
        }
    }

    return best;
}

bool intersectTlas(Ray ray, inout HitInfo hitInfo)
{
    // Assumes ray.direction is normalized in raygen (so tWorld can be computed via dot(delta, dir)).
    for (uint i = 0u; i < tlasInstances.instanceCount; ++i)
    {
        Instance instance = tlasInstances.instances[i];
        InverseTransforms instanceInverseTransform = tlasInstanceTransforms.inv[i];

        // Transform ray to object space.
        vec3 localO = (instanceInverseTransform.worldToObj * vec4(ray.origin, 1.0)).xyz;
        vec3 localD = (instanceInverseTransform.worldToObj * vec4(ray.direction, 0.0)).xyz;

        // Avoid inf/nan invDirection if localD has zeros
        Ray localRay;
        localRay.origin = localO;
        localRay.direction = localD;
        localRay.invDirection = 1.0 / localD;

        // Fetch BLAS info (blasAddress is used as an index in the compute path).
        BlasInfo blasInfo = blasInfos.blases[instance.blasAddress];
        uint bvhBase = blasInfo.rootNodeIndex;
        uint triangleOffset = blasInfo.triangleOffset;

        // Traverse in object space, but keep the best.t bound in world space (convert on accept).
        HitInfo hit = traverseBVH(bvhBase, triangleOffset, localRay, 0.001, hitInfo.t);

        if (hit.triangleIndex != INVALID_INDEX)
        {
            // Convert local hit position to world space
            vec3 hitPosLocal = localRay.origin + localRay.direction * hit.t;
            vec3 hitPosWorld = (instanceInverseTransform.objToWorld * vec4(hitPosLocal, 1.0)).xyz;

            // Calculate world-space t using distance since transforms may include scaling
            float tWorld = length(hitPosWorld - ray.origin);

            // Reject if behind ray or farther than current best
            if (tWorld > 0.0 && tWorld < hitInfo.t)
            {
                hit.t = tWorld;
                hit.instanceIndex = i;
                vec3 n = vec3(hit.normalX, hit.normalY, hit.normalZ);
                // Transform normal to world space
                n = normalize((transpose(instanceInverseTransform.worldToObj) * vec4(n, 0.0)).xyz);
                hit.normalX = n.x;
                hit.normalY = n.y;
                hit.normalZ = n.z;
                hitInfo = hit;
            }
        }
    }

    return (hitInfo.triangleIndex != INVALID_INDEX);
}

void main()
{
    uint tid = gl_GlobalInvocationID.x;
    if (tid >= rayQueue.count) {
        return;
    }
    uint rayIndex = rayQueue.rayIndices[tid];
    PathHeader header = getPathHeader(rayIndex);
    Ray ray;
    ray.origin = vec3(header.originX, header.originY, header.originZ);
    ray.direction = vec3(header.directionX, header.directionY, header.directionZ);
    ray.invDirection = 1.0 / ray.direction;

    HitInfo hitInfo;
    hitInfo.t = header.tMax;
    hitInfo.triangleIndex = INVALID_INDEX;
    hitInfo.instanceIndex = INVALID_INDEX;
    hitInfo.barycentricU = 0.0;
    hitInfo.barycentricV = 0.0;

    // Perform TLAS intersection
    bool hit = intersectTlas(ray, hitInfo);

    // Write hit info to buffer
    hitInfos.hits[rayIndex] = hitInfo;
}