#version 450
layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;

layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
} pc;

uvec2 getResolution() {
    return uvec2(pc.width, pc.height);
}

struct PathHeader {
    float originX;
    float originY;
    float originZ;
    float tMin;

    float directionX;
    float directionY;
    float directionZ;
    float tMax;
};

struct HitInfo {
    float t;
    uint triangleIndex;
    uint instanceIndex;
    float barycentricU;
    float barycentricV;
};

// Note: TLAS uses bindings 0-5, user bindings start at 6+
// Wavefront internal buffers use bindings 50-52 to avoid conflicts
layout (std430, binding = 50, set = 0) readonly buffer PathHeaders {
    PathHeader headers[];
} pathHeaders;

layout(std430, binding = 51, set = 0) readonly buffer RayQueue {
    uint count;
    uint rayIndices[];
} rayQueue;

layout(std430, binding = 52, set = 0) readonly buffer HitInfos {
    HitInfo hits[];
} hitInfos;

// User-defined bindings
//___USER_PARAMS___

// Helper: set new ray for secondary bounces (stub for now - not used in phase 1)
void setNewRay(vec3 origin, vec3 direction, float tmin, float tmax) {
    // Will be implemented when adding bounce support
}

// User shader function
void hit_shader_main();
//___HIT_SHADER_FUNCTION___

void main() {
    uint workItemId = gl_GlobalInvocationID.x;
    if (workItemId >= rayQueue.count) return;

    uint rayIndex = rayQueue.rayIndices[workItemId];

    // Check if this ray hit geometry (triangleIndex != 0xFFFFFFFF)
    if (hitInfos.hits[rayIndex].triangleIndex == 0xFFFFFFFF) return;

    // Call user hit shader
    hit_shader_main();
}