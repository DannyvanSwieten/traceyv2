#version 450


struct PathHeader {
    float originX;
    float originY;
    float originZ;
    float tMin;

    float directionX;
    float directionY;
    float directionZ;
    float tMax;
};

struct Ray{
    vec3 origin;
    vec3 direction;
    float tMin;
    float tMax;
};

layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
} pc;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
layout (std430, binding = 0, set = 0) writeonly buffer RayGenOutput {
    PathHeader header[];
} PathInfos;

layout(std430, binding = 1, set = 0) writeonly buffer IntersectionQueue {
    uint count;
    uint rayIndices[];
};

void enqueue_intersection(uint rayIndex) {
    // Dense (bounce-0 style) initialization: rayIndices[i] = i
    rayIndices[rayIndex] = rayIndex;
}

uvec2 getResolution() {
    return uvec2(pc.width, pc.height);
}

Ray ray_gen_main(uvec2 pixel);

//___USER_PARAMS___
//___RAY_GENERATION_FUNCTION___

void main() {
    if (pc.width == 0u || pc.height == 0u) {
        return;
    }

    uint rayCount = pc.width * pc.height;

    uint index = gl_GlobalInvocationID.x;
    if (index >= rayCount) {
        return;
    }

    uvec2 pixelCoord = uvec2(index % pc.width, index / pc.width);
    if (pixelCoord.y >= pc.height) {
        return;
    }

    // Provide pixel coordinates to user raygen code.
    Ray ray = ray_gen_main(pixelCoord);

    // Set queue count once for a dense initial queue.
    if (index == 0u) {
        count = rayCount;
    }

    enqueue_intersection(index);
    PathHeader header;
    header.originX = ray.origin.x;
    header.originY = ray.origin.y;
    header.originZ = ray.origin.z;
    header.directionX = ray.direction.x;
    header.directionY = ray.direction.y;
    header.directionZ = ray.direction.z;
    header.tMin = ray.tMin;
    header.tMax = ray.tMax;
    PathInfos.header[index] = header;
}