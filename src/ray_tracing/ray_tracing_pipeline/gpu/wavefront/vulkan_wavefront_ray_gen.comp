#version 450


struct PathHeader {
    float originX;
    float originY;
    float originZ;
    float tMin;

    float directionX;
    float directionY;
    float directionZ;
    float tMax;
};

struct Ray{
    vec3 origin;
    vec3 direction;
    float tMin;
    float tMax;
};

layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
} pc;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
layout (std430, binding = 50, set = 0) writeonly buffer RayGenOutput {
    PathHeader header[];
} PathInfos;

// NOTE: Can't use writeonly because count is initialized from CPU
layout(std430, binding = 51, set = 0) buffer IntersectionQueue {
    uint count;
    uint padding[3];
    uint rayIndices[];
} rayQueue;

void enqueue_intersection(uint rayIndex) {
    // Dense (bounce-0 style) initialization: rayIndices[i] = i
    rayQueue.rayIndices[rayIndex] = rayIndex;
}

uvec2 getResolution() {
    return uvec2(pc.width, pc.height);
}

// Global ray index for this invocation (used by traceRay to know which payload slot to use)
uint g_RayIndex = 0u;

void traceRay(vec3 origin, float tMin, vec3 direction, float tMax)
{
    PathHeader header;
    header.originX = origin.x;
    header.originY = origin.y;
    header.originZ = origin.z;
    header.directionX = direction.x;
    header.directionY = direction.y;
    header.directionZ = direction.z;
    header.tMin = tMin;
    header.tMax = tMax;

    // Use the global ray index (set in main) - this corresponds to the payload index
    uint rayIndex = g_RayIndex;

    PathInfos.header[rayIndex] = header;
    enqueue_intersection(rayIndex);

    // Atomically increment count to track total rays queued
    atomicAdd(rayQueue.count, 1);
}

//___USER_PARAMS___

// User shader function signature - will receive payload reference
//___RAY_GEN_SIGNATURE___

//___RAY_GENERATION_FUNCTION___

void main() {
    if (pc.width == 0u || pc.height == 0u) {
        return;
    }

    uint rayCount = pc.width * pc.height;

    uint index = gl_GlobalInvocationID.x;
    if (index >= rayCount) {
        return;
    }

    uvec2 pixelCoord = uvec2(index % pc.width, index / pc.width);
    if (pixelCoord.y >= pc.height) {
        return;
    }

    // Set global ray index for traceRay to use
    g_RayIndex = index;

    // Call user raygen code with payload reference
    //___RAY_GEN_CALL___
}