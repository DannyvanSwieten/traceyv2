#version 450


struct PathHeader {
    float originX;
    float originY;
    float originZ;
    float tMin;

    float directionX;
    float directionY;
    float directionZ;
    float tMax;
};

struct Ray{
    vec3 origin;
    vec3 direction;
    float tMin;
    float tMax;
};

layout(push_constant) uniform PushConstants {
    uint width;
    uint height;
} pc;

layout (local_size_x = 256, local_size_y = 1, local_size_z = 1) in;
layout (std430, binding = 50, set = 0) writeonly buffer RayGenOutput {
    PathHeader header[];
} PathInfos;

layout(std430, binding = 51, set = 0) writeonly buffer IntersectionQueue {
    uint count;
    uint padding[3];
    uint rayIndices[];
};

void enqueue_intersection(uint rayIndex) {
    // Dense (bounce-0 style) initialization: rayIndices[i] = i
    rayIndices[rayIndex] = rayIndex;
}

uvec2 getResolution() {
    return uvec2(pc.width, pc.height);
}

void traceRay(vec3 origin, float tMin, vec3 direction, float tMax)
{
    PathHeader header;
    header.originX = origin.x;
    header.originY = origin.y;
    header.originZ = origin.z;
    header.directionX = direction.x;
    header.directionY = direction.y;
    header.directionZ = direction.z;
    header.tMin = tMin;
    header.tMax = tMax;

    uint index = gl_GlobalInvocationID.x;
    PathInfos.header[index] = header;
    enqueue_intersection(index);
}

//___USER_PARAMS___

// User shader function signature - will receive payload reference
//___RAY_GEN_SIGNATURE___

//___RAY_GENERATION_FUNCTION___

void main() {
    if (pc.width == 0u || pc.height == 0u) {
        return;
    }

    uint rayCount = pc.width * pc.height;

    uint index = gl_GlobalInvocationID.x;
    if (index >= rayCount) {
        return;
    }

    uvec2 pixelCoord = uvec2(index % pc.width, index / pc.width);
    if (pixelCoord.y >= pc.height) {
        return;
    }

    // Call user raygen code with payload reference
    //___RAY_GEN_CALL___

    // Set queue count once for a dense initial queue.
    if (index == 0u) {
        count = rayCount;
    }
}