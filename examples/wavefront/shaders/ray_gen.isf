/*{
    "STAGE": "RayGeneration",
    "DESCRIPTION": "Pinhole camera with jittered anti-aliasing",
    "INPUTS": [
        { "NAME": "fov", "TYPE": "float", "DEFAULT": 45.0, "MIN": 10.0, "MAX": 120.0 }
    ],
    "PAYLOADS": [{
        "NAME": "rayPayload",
        "FIELDS": [
            { "NAME": "color", "TYPE": "vec3" },
            { "NAME": "direction", "TYPE": "vec3" },
            { "NAME": "depth", "TYPE": "uint" },
            { "NAME": "alive", "TYPE": "bool" },
            { "NAME": "sampleIndex", "TYPE": "uint" },
            { "NAME": "rngSeed", "TYPE": "uint" }
        ]
    }]
}*/

// Simple hash function for random number generation
float hash(uint seed) {
    seed = (seed ^ 61u) ^ (seed >> 16u);
    seed *= 9u;
    seed = seed ^ (seed >> 4u);
    seed *= 0x27d4eb2du;
    seed = seed ^ (seed >> 15u);
    return float(seed) / 4294967296.0;
}

void shader(uvec2 pixelCoord, inout RayPayloads payloads) {
    uvec2 resolution = getResolution();

    // Initialize RNG seed based on pixel coordinates and sample index
    payloads.rayPayload.rngSeed = pixelCoord.x + pixelCoord.y * resolution.x +
                                   payloads.rayPayload.sampleIndex * resolution.x * resolution.y;

    // Generate random sub-pixel jitter for anti-aliasing
    float jitterX = hash(payloads.rayPayload.rngSeed);
    float jitterY = hash(payloads.rayPayload.rngSeed + 1u);

    // Create a simple pinhole camera ray direction with jittered sample position
    float width = float(resolution.x);
    float height = float(resolution.y);
    float aspectRatio = width / height;
    // Use fov from shaderInputs uniform buffer
    float px = (2.0 * ((float(pixelCoord.x) + jitterX) / width) - 1.0) * tan(radians(shaderInputs.fov) / 2.0) * aspectRatio;
    float py = (1.0 - 2.0 * ((float(pixelCoord.y) + jitterY) / height)) * tan(radians(shaderInputs.fov) / 2.0);

    vec3 origin = vec3(0.0, 0.0, 0.0);
    vec3 direction = normalize(vec3(px, py, 1.0));

    // Initialize payload for path tracing
    payloads.rayPayload.direction = direction;
    payloads.rayPayload.color = vec3(1.0); // Start with white - will be multiplied by albedo at each bounce
    payloads.rayPayload.depth = 0u;
    payloads.rayPayload.alive = true;
    payloads.rayPayload.sampleIndex += 1u;

    traceRay(origin, 0.01, direction, 1000.0);
}
